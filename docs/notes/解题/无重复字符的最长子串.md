# 野路子搞算法·让算法可视化《无重复字符的最长子串》

## 一、前言

在刷了一道 `leetcode` 的题以后一直在思考，怎么才能让小白更清楚的了解到整个算法运行的过程。如果只是单纯的一点点看代码，从中摸清楚整个流程确实还是有一些难度。虽然就一道题来说，代码块并不会很大，但仅凭借变量之间的交换以及断点输出结果，还是很难在我们的大脑中形成一个完整的执行流程。为此，最近经过不断的在搜索在Github中找到了 [```MarkKoz```](https://github.com/algorithm-visualizer) 大神的算法可视化代码：[algorithm-visualizer](https://github.com/algorithm-visualizer) 。在按照文档说明安装以及写案例测试后，确实可以满足目前的需求。好！那么我就按照自己的需求，将代码部署到本地以及创建了一套符合自己需求的算法可视化工程。

这套功能包括三部分，如下；

| 序号 | 名称 | 功能  | 操作 |
|:---|:---|:---|:---:|
| 1 | algorithm-visualizer | 可视化算法代码平台，目前支持的算法包括回溯法、加密算法、动态规划、图搜索、贪婪算法、搜索算法、排序算法等。 |  [下载](https://github.com/niubility-algorithm)  |
| 2 | server | 算法可视化服务器，用于编译算法代码提供服务接口。这个编译过程会从 `github` 上下载算法代码，并编译到本地。| [下载](https://github.com/niubility-algorithm)  |
| 3 | algorithms | 算法代码块，这里面默认包括了大量的可执行展示的算法。同时在我们刷 `leetcode` 后也是将代码编写为可视化的方式，提交到这里。| [下载](https://github.com/niubility-algorithm)  |

**展示一下：**

![](http://niubility-algorithm.itstack.org/assets/img/2020/niubility-algorithm-0003-01.png)

- 最左侧是代码区域，也就是我们提交到 ```algorithms``` 中的算法代码。*不支持中文以及特殊符号*
- 中间是展示运行过程区域，这部分主要来自于在算法代码中添加的展示化代码块，例如：```array1DTracer.select(beginIdx, i - 1);```
- 最右侧是代码区域，这里的代码可以修改后构建并运行，但不会保存。同时在运行的时候可以调整运行速度 ```Speed```，极大的方便了我们观察算法的执行过程
- 上图的展示内容其实就是我们在 `leetcode` 中做的第一题《两数之和》其中的一中使用自己定义的 `bit` 结构数组的方式求解的演示

那么！接下来我们开始刷 ```leetcode``` 中第三题《无重复字符的最长子串》，并最终动态展示给大家这段算法的执行效果。如果你想在本地运行，可以关注公众号：```bugstack虫洞栈```

## 二、题目：《无重复字符的最长子串》

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```java
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```                                                     

**示例 2:**

```java
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
``` 

**示例 3:**

```java
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

>java

```java 
class Solution {
    public int lengthOfLongestSubstring(String s) {
       // TODO
    }
}
```

## 三、思路和实现



## 四、实现

## 五、总结